// 🚀 FRESH VERCEL SERVERLESS FUNCTION - NO IMPORTS
// Created: 2025-01-22 16:00 - Force cache busting by creating new file
// This function is completely self-contained with zero dependencies

module.exports = async function (req, res) {
  console.log('🚀 Fresh serverless function called:', req.method);
  
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  // Handle preflight
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  // Health check endpoint
  if (req.method === 'GET') {
    return res.status(200).json({
      success: true,
      message: '🚀 Fresh API endpoint working perfectly!',
      timestamp: new Date().toISOString(),
      version: 'v2.0-fresh',
      noImports: true,
      selfContained: true
    });
  }

  // Only allow POST for actual processing
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false, 
      error: 'Only POST requests allowed for processing' 
    });
  }

  try {
    // Parse request body
    const body = req.body;
    if (!body) {
      return res.status(400).json({
        success: false,
        error: 'Request body is required'
      });
    }

    const { deliveryText, planText } = body;
    
    if (!deliveryText || !planText) {
      return res.status(400).json({
        success: false,
        error: 'Both deliveryText and planText are required',
        received: {
          hasDeliveryText: !!deliveryText,
          hasPlanText: !!planText
        }
      });
    }

    console.log('📊 Processing delivery comparison...');

    // EMBEDDED ANALYSIS LOGIC - NO IMPORTS NEEDED
    const planLines = planText.split('\n').filter(line => line.trim().length > 2);
    const deliveryLines = deliveryText.split('\n').filter(line => line.trim().length > 2);
    
    let planClientCount = 0;
    let deliveredClientCount = 0;
    
    // Count planned clients (look for tabs or numbers)
    for (const line of planLines) {
      const trimmed = line.trim();
      if (trimmed.includes('\t') || /\d/.test(trimmed)) {
        planClientCount++;
      }
    }
    
    // Count delivered clients (look for Arabic quantity keywords)
    for (const line of deliveryLines) {
      const trimmed = line.trim();
      if (trimmed.includes('صغير') || trimmed.includes('كبير') || 
          trimmed.includes('ص') || trimmed.includes('ك') ||
          trimmed.includes('كوب')) {
        deliveredClientCount++;
      }
    }
    
    const missedCount = Math.max(0, planClientCount - deliveredClientCount);
    const successRate = planClientCount > 0 ? Math.round((deliveredClientCount / planClientCount) * 100) : 0;
    
    const reportDate = new Date().toDateString();
    
    const analysisResult = `🚀 Fresh API Delivery Analysis
📅 Analysis Date: ${reportDate}

✅ DELIVERED CLIENTS: ${deliveredClientCount}
❌ MISSED CLIENTS: ${missedCount} 
📈 SUCCESS RATE: ${successRate}%

📊 BREAKDOWN:
• Total Planned: ${planClientCount}
• Successfully Delivered: ${deliveredClientCount}
• Missed/Pending: ${missedCount}

🔥 Generated by self-contained serverless function (no imports!)`;

    console.log('✅ Analysis completed successfully');

    return res.status(200).json({
      success: true,
      version: 'v2.0-fresh',
      result: {
        formattedOutput: analysisResult,
        summary: {
          totalPlanned: planClientCount,
          totalDelivered: deliveredClientCount,
          missed: missedCount,
          fulfillmentRate: successRate
        },
        metadata: {
          timestamp: new Date().toISOString(),
          planLinesProcessed: planLines.length,
          deliveryLinesProcessed: deliveryLines.length,
          selfContained: true,
          noImports: true
        }
      }
    });

  } catch (error) {
    console.error('❌ Fresh serverless function error:', error);
    return res.status(500).json({
      success: false,
      error: 'Processing failed in fresh function',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
}; 